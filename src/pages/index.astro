<style>
  /* ... keep previous styles ... */

  /* Fly-in animations remain unchanged */

  /* New fly-out animations */
  @keyframes flyOutLeft {
    from { transform: translateX(0) rotate(0deg) scale(1.1); opacity: 1; }
    to { transform: translateX(-150%) rotate(-10deg) scale(1.1); opacity: 0; }
  }

  @keyframes flyOutRight {
    from { transform: translateX(0) rotate(0deg) scale(1.1); opacity: 1; }
    to { transform: translateX(150%) rotate(10deg) scale(1.1); opacity: 0; }
  }

  /* When a section is leaving */
  section[data-visible="leaving"] .plane {
    animation-fill-mode: forwards;
    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    animation-duration: 1.5s;
    opacity: 0;
  }

  section[data-visible="leaving"][data-side="left"] .plane {
    animation-name: flyOutLeft;
  }
  section[data-visible="leaving"][data-side="right"] .plane {
    animation-name: flyOutRight;
  }

  /* Hide title on leaving */
  section[data-visible="leaving"] .title {
    opacity: 0;
    transition: opacity 0.4s ease;
  }
</style>

<script>
  (() => {
    const container = document.getElementById("container");
    const sections = container.querySelectorAll("section");
    let current = 0;
    const total = sections.length;
    let isAnimating = false;

    function updateVisible(newIndex) {
      if (newIndex < 0 || newIndex >= total) return;
      if (newIndex === current) return;
      if (isAnimating) return;
      isAnimating = true;

      const currentSection = sections[current];
      const nextSection = sections[newIndex];

      // Mark current as leaving to trigger fly out
      currentSection.dataset.visible = "leaving";

      // After fly-out animation ends (~1.5s), hide old and show new
      setTimeout(() => {
        currentSection.dataset.visible = "false";

        // Show next section, triggers fly-in
        nextSection.dataset.visible = "true";

        current = newIndex;

        // Wait for fly-in animation (~1.5s) before allowing new navigation
        setTimeout(() => {
          isAnimating = false;
        }, 1500);
      }, 1500);
    }

    // Touch/swipe and wheel handlers (same as before)
    let startY = null;
    container.addEventListener("touchstart", (e) => {
      if(e.touches.length !== 1) return;
      startY = e.touches[0].clientY;
    }, { passive: true });

    container.addEventListener("touchend", (e) => {
      if(startY === null) return;
      const endY = e.changedTouches[0].clientY;
      const diff = startY - endY;
      if(Math.abs(diff) < 30) return;

      if(diff > 0) updateVisible(current + 1);
      else updateVisible(current - 1);

      startY = null;
    }, { passive: true });

    container.addEventListener("wheel", (e) => {
      if (isAnimating) return;
      if (e.deltaY > 30) updateVisible(current + 1);
      else if (e.deltaY < -30) updateVisible(current - 1);
    });
  })();
</script>
